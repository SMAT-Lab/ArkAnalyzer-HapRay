# 帧分析模块设计文档

## 1. 架构设计

### 1.1 整体架构

帧分析模块采用分层架构设计，从顶层到底层分为：

```
┌─────────────────────────────────────────┐
│   UnifiedFrameAnalyzer (统一入口)       │
│   - 统一管理所有帧分析                  │
│   - 协调多个分析器                       │
│   - 管理报告输出                         │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│   FrameAnalyzerCore (核心协调器)        │
│   - 协调各个专门分析器                   │
│   - 管理数据库连接                       │
│   - 提供统一的分析接口                   │
└──────────────┬──────────────────────────┘
               │
    ┌──────────┼──────────┐
    │          │          │
┌───▼───┐ ┌───▼───┐ ┌───▼──────────┐
│ 空帧  │ │ 卡顿  │ │ VSync异常     │
│分析器 │ │帧分析 │ │ 分析器        │
└───┬───┘ └───┬───┘ └───┬──────────┘
    │          │          │
    └──────────┼──────────┘
               │
┌──────────────▼──────────────────────────┐
│   FrameCacheManager (缓存管理器)        │
│   - 管理数据缓存                        │
│   - 数据库连接管理                      │
│   - 数据访问委托                        │
└──────────────┬──────────────────────────┘
               │
    ┌──────────┼──────────┐
    │          │          │
┌───▼───┐ ┌───▼───┐ ┌───▼──────────┐
│负载   │ │Perf   │ │Trace          │
│计算器 │ │访问器 │ │访问器         │
└───────┘ └───────┘ └───────────────┘
```

### 1.2 模块职责划分

#### 1.2.1 统一入口层
- **UnifiedFrameAnalyzer**: 统一管理所有帧分析任务，负责：
  - 初始化核心分析器
  - 协调多个分析任务
  - 管理多个报告输出路径
  - 结果汇总和报告生成

#### 1.2.2 核心协调层
- **FrameAnalyzerCore**: 核心分析协调器，负责：
  - 初始化各个专门分析器
  - 管理数据库连接生命周期
  - 提供统一的分析接口
  - 协调缓存管理器

#### 1.2.3 专门分析层
- **EmptyFrameAnalyzer**: 空帧分析器
- **StutteredFrameAnalyzer**: 卡顿帧分析器
- **VSyncAnomalyAnalyzer**: VSync异常分析器

#### 1.2.4 核心组件层
- **FrameCacheManager**: 缓存管理器，负责：
  - 数据缓存管理
  - 数据库连接管理
  - 数据访问接口提供
  - 缓存命中率统计

- **FrameLoadCalculator**: 帧负载计算器，负责：
  - 帧负载计算
  - 调用链分析
  - 样本调用链构建

#### 1.2.5 数据访问层
- **FramePerfAccessor**: Perf数据库访问器
- **FrameTraceAccessor**: Trace数据库访问器

#### 1.2.6 工具层
- **FrameTimeUtils**: 时间工具类
- **FrameUtils**: 通用工具类
- **FrameConstants**: 常量定义

### 1.3 数据流

```
Trace/Perf数据库
    ↓
FrameCacheManager (缓存管理)
    ↓
FrameAnalyzerCore (核心协调)
    ↓
专门分析器 (Empty/Stuttered/VSync)
    ↓
FrameLoadCalculator (负载计算)
    ↓
UnifiedFrameAnalyzer (结果汇总)
    ↓
报告文件 (JSON)
```

### 1.4 设计原则

1. **单一职责原则**: 每个类只负责一个明确的功能
2. **依赖注入**: 通过构造函数注入依赖，便于测试和扩展
3. **缓存优化**: 使用缓存减少数据库查询次数
4. **模块化设计**: 各分析器独立，可单独使用
5. **统一接口**: 通过FrameAnalyzerCore提供统一的分析接口

## 2. 类描述

### 2.1 UnifiedFrameAnalyzer

**位置**: `hapray/analyze/unified_frame_analyzer.py`

**继承**: `BaseAnalyzer`

**职责**: 统一帧分析器，整合帧负载、空帧、卡顿帧和VSync异常分析

**主要功能**:
- 统一管理所有帧相关的分析
- 使用FrameAnalyzerCore进行核心分析
- 保持各分析器的输出路径不变
- 优化性能，共享缓存和数据库连接

**关键属性**:
- `top_frames_count`: Top帧数量，默认10
- `report_paths`: 各分析器的输出路径映射
- `frame_loads_results`: 帧负载分析结果
- `empty_frame_results`: 空帧分析结果
- `frame_drop_results`: 卡顿帧分析结果
- `vsync_anomaly_results`: VSync异常分析结果

### 2.2 FrameAnalyzerCore

**位置**: `hapray/core/common/frame/frame_core_analyzer.py`

**职责**: 帧分析核心协调器，使用模块化组件进行职责分离

**主要功能**:
- 数据访问协调 - 通过FrameCacheManager
- 负载计算协调 - 通过FrameLoadCalculator
- 空帧分析协调 - 通过EmptyFrameAnalyzer
- 卡顿帧分析协调 - 通过StutteredFrameAnalyzer
- VSync异常分析协调 - 通过VSyncAnomalyAnalyzer

**关键属性**:
- `cache_manager`: 缓存管理器实例
- `load_calculator`: 负载计算器实例
- `empty_frame_analyzer`: 空帧分析器实例
- `stuttered_frame_analyzer`: 卡顿帧分析器实例
- `vsync_anomaly_analyzer`: VSync异常分析器实例

### 2.3 EmptyFrameAnalyzer

**位置**: `hapray/core/common/frame/frame_analyzer_empty.py`

**职责**: 专门用于分析空帧（flag=2, type=0）的负载情况

**主要功能**:
- 空帧负载计算
- 主线程vs后台线程分析
- 空帧调用链分析
- Top帧识别和分析

**帧标志说明**:
- `flag = 0`: 实际渲染帧不卡帧（正常帧）
- `flag = 1`: 实际渲染帧卡帧
- `flag = 2`: 数据不需要绘制（空帧，本分析器专门分析此类帧）
- `flag = 3`: rs进程与app进程起止异常

### 2.4 StutteredFrameAnalyzer

**位置**: `hapray/core/common/frame/frame_analyzer_stuttered.py`

**职责**: 专门用于分析卡顿帧

**主要功能**:
- 卡顿帧检测和分级
- FPS计算和统计
- 卡顿详情分析
- 卡顿率统计

**卡顿分级策略**:
- **等级 1 (轻微卡顿)**: flag=3 或 flag=1 且超出帧数 < 2
- **等级 2 (中度卡顿)**: flag=1 且超出帧数 2-6
- **等级 3 (严重卡顿)**: flag=1 且超出帧数 > 6

### 2.5 VSyncAnomalyAnalyzer

**位置**: `hapray/core/common/frame/frame_analyzer_vsync.py`

**职责**: 专门用于分析VSync信号的异常情况

**主要功能**:
- VSync频率异常检测（高频/低频时间段）
- VSync与帧的不匹配检测
- 异常率统计
- 时间段异常分析

**异常类型**:
- 高频时间段异常
- 低频时间段异常
- 无实际帧异常
- 无期望帧异常

### 2.6 FrameCacheManager

**位置**: `hapray/core/common/frame/frame_core_cache_manager.py`

**继承**: `FramePerfAccessor`, `FrameTraceAccessor`

**职责**: 帧缓存管理器，负责缓存管理和数据访问委托

**主要功能**:
- 管理各种数据缓存（帧数据、性能数据、调用链等）
- 数据库连接管理（trace和perf数据库）
- 缓存命中率统计
- 提供统一的数据访问接口

**缓存策略**:
- 使用装饰器模式实现自动缓存
- 支持DataFrame缓存
- 缓存命中率统计

### 2.7 FrameLoadCalculator

**位置**: `hapray/core/common/frame/frame_core_load_calculator.py`

**职责**: 帧负载计算器，负责计算帧的负载和调用链分析

**主要功能**:
- 帧负载计算
- 调用链分析
- 样本调用链构建
- VSync过滤

**关键方法**:
- `calculate_all_frame_loads_fast()`: 快速计算所有帧负载
- `analyze_single_frame()`: 分析单个帧的调用链
- `analyze_perf_callchain()`: 分析perf样本的调用链信息

### 2.8 FramePerfAccessor

**位置**: `hapray/core/common/frame/frame_perf_accessor.py`

**职责**: Perf数据库访问器，专门处理perf数据库的所有操作

**主要功能**:
- 从perf数据库读取原始数据（性能采样、调用链、文件等）
- 执行SQL查询和数据过滤
- 标准化数据格式，处理NaN值
- 提供统一的perf数据访问接口

**关键方法**:
- `get_perf_samples()`: 获取性能采样数据
- `get_callchain_cache()`: 获取调用链缓存
- `get_files_cache()`: 获取文件缓存

### 2.9 FrameTraceAccessor

**位置**: `hapray/core/common/frame/frame_trace_accessor.py`

**职责**: Trace数据库访问器，专门处理trace数据库的所有操作

**主要功能**:
- 从trace数据库读取原始数据（帧、进程、线程、调用栈等）
- 执行SQL查询和数据过滤
- 标准化数据格式，处理NaN值
- 提供统一的trace数据访问接口

**关键方法**:
- `get_frames_data()`: 获取标准化的帧数据
- `get_empty_frames_with_details()`: 获取空帧详细信息
- `parse_frame_slice_db()`: 解析帧切片数据库

## 3. Public函数说明

### 3.1 UnifiedFrameAnalyzer

#### `__init__(scene_dir: str, top_frames_count: int = 10)`

初始化统一帧分析器

**参数**:
- `scene_dir`: 场景目录路径
- `top_frames_count`: Top帧数量，默认10

**说明**: 初始化分析器，定义各分析器的输出路径

---

#### `_analyze_impl(step_dir: str, trace_db_path: str, perf_db_path: str, app_pids: list) -> Optional[dict[str, Any]]`

实现统一帧分析逻辑

**参数**:
- `step_dir`: 步骤标识符
- `trace_db_path`: trace数据库路径
- `perf_db_path`: perf数据库路径
- `app_pids`: 应用进程ID列表

**返回**:
- `Optional[dict[str, Any]]`: 包含统一帧分析结果的字典，如果没有数据则返回None

**说明**: 
- 在方法中新建FrameAnalyzerCore，传入数据库路径和进程ID
- 依次执行帧负载、空帧、卡顿帧和VSync异常分析
- 返回合并结果用于主报告

---

#### `write_report(result: dict)`

写入报告 - 支持多个输出路径

**参数**:
- `result`: 主结果字典

**说明**: 
- 保持各分析器的输出路径不变，分别写入对应的JSON文件
- 同时更新主结果字典

---

#### `_write_single_report(results: dict, report_path: str)`

写入单个报告文件

**参数**:
- `results`: 结果字典
- `report_path`: 报告路径

**说明**: 将结果写入JSON文件

---

#### `_update_result_dict(result: dict, results: dict, report_path: str)`

更新主结果字典

**参数**:
- `result`: 主结果字典
- `results`: 要更新的结果字典
- `report_path`: 报告路径（用于构建嵌套结构）

**说明**: 根据报告路径构建嵌套字典结构并更新结果

---

#### `_clean_data_for_json(data)`

清理数据，确保JSON序列化安全

**参数**:
- `data`: 要清理的数据

**返回**: 清理后的数据

**说明**: 处理numpy类型、NaN值等，确保可以正确序列化为JSON

### 3.2 FrameAnalyzerCore

#### `__init__(debug_vsync_enabled: bool = False, trace_db_path: Optional[str] = None, perf_db_path: Optional[str] = None, app_pids: Optional[list] = None, step_dir: Optional[str] = None)`

初始化FrameAnalyzerCore

**参数**:
- `debug_vsync_enabled`: VSync调试开关
- `trace_db_path`: trace数据库文件路径
- `perf_db_path`: perf数据库文件路径
- `app_pids`: 应用进程ID列表
- `step_dir`: 步骤标识符

**说明**: 初始化缓存管理器和各个专门的分析器

---

#### `analyze_empty_frames() -> Optional[dict]`

分析空帧（flag=2, type=0）的负载情况

**返回**:
- `Optional[dict]`: 包含分析结果，如果没有数据则返回None

**说明**: 委托给EmptyFrameAnalyzer执行分析

---

#### `analyze_stuttered_frames() -> Optional[dict]`

分析卡顿帧数据并计算FPS

**返回**:
- `Optional[dict]`: 分析结果数据，如果没有数据或分析失败则返回None

**说明**: 委托给StutteredFrameAnalyzer执行分析

---

#### `analyze_vsync_anomalies() -> Optional[dict[str, Any]]`

分析VSync异常

**返回**:
- `Optional[dict[str, Any]]`: VSync异常分析结果，如果没有数据或分析失败则返回None

**说明**: 委托给VSyncAnomalyAnalyzer执行分析

---

#### `analyze_frame_loads_fast(step_id: str = None) -> dict[str, Any]`

快速分析所有帧的负载值（不分析调用链）

**参数**:
- `step_id`: 步骤ID

**返回**:
- `dict[str, Any]`: 帧负载分析结果

**说明**: 
- 这是FrameLoad阶段的优化版本，只计算负载值，不进行调用链分析
- 包括统计信息、Top帧列表和总帧数

---

#### `close_connections() -> None`

关闭数据库连接

**说明**: 关闭缓存管理器中的数据库连接

### 3.3 EmptyFrameAnalyzer

#### `__init__(debug_vsync_enabled: bool = False, cache_manager: FrameCacheManager = None)`

初始化空帧分析器

**参数**:
- `debug_vsync_enabled`: VSync调试开关
- `cache_manager`: 缓存管理器实例

---

#### `analyze_empty_frames() -> Optional[dict]`

分析空帧（flag=2, type=0）的负载情况

**返回**:
- `Optional[dict]`: 包含分析结果的字典

**说明**: 
- 空帧定义：flag=2 表示数据不需要绘制（没有frameNum信息）
- 包括主线程和后台线程的Top帧分析
- 包含负载统计和百分比计算

### 3.4 StutteredFrameAnalyzer

#### `__init__(debug_vsync_enabled: bool = False, cache_manager: FrameCacheManager = None)`

初始化卡顿帧分析器

**参数**:
- `debug_vsync_enabled`: VSync调试开关（保留以兼容接口）
- `cache_manager`: 缓存管理器实例

---

#### `analyze_stuttered_frames() -> Optional[dict]`

分析卡顿帧数据并计算FPS

**返回**:
- `Optional[dict]`: 分析结果数据，如果没有数据或分析失败则返回None

**说明**: 
- 包括卡顿分级统计
- FPS窗口分析
- 卡顿详情列表
- 卡顿率计算

### 3.5 VSyncAnomalyAnalyzer

#### `__init__(cache_manager: FrameCacheManager = None)`

初始化VSync异常分析器

**参数**:
- `cache_manager`: 缓存管理器实例

---

#### `analyze_vsync_anomalies(app_pids: list) -> Optional[dict[str, Any]]`

分析VSync异常

**参数**:
- `app_pids`: 应用进程ID列表

**返回**:
- `Optional[dict[str, Any]]`: VSync异常分析结果，如果没有数据或分析失败则返回None

**说明**: 
- 包括频率异常检测
- 帧不匹配检测
- 异常率统计

### 3.6 FrameCacheManager

#### `__init__(trace_db_path: Optional[str] = None, perf_db_path: Optional[str] = None, app_pids: Optional[list] = None)`

初始化帧缓存管理器

**参数**:
- `trace_db_path`: trace数据库路径
- `perf_db_path`: perf数据库路径
- `app_pids`: 应用进程ID列表

**说明**: 初始化数据库连接和缓存字典

---

#### `get_frames_data(app_pids: list = None) -> pd.DataFrame`

获取标准化的帧数据

**参数**:
- `app_pids`: 应用进程ID列表，如果提供则只返回这些进程的数据

**返回**:
- `pd.DataFrame`: 标准化的帧数据

**说明**: 使用缓存装饰器，自动缓存结果

---

#### `get_perf_samples() -> pd.DataFrame`

获取性能采样数据

**返回**:
- `pd.DataFrame`: 标准化的性能采样数据

**说明**: 使用缓存装饰器，自动缓存结果

---

#### `get_empty_frames_with_details(app_pids: list) -> pd.DataFrame`

获取空帧详细信息

**参数**:
- `app_pids`: 应用进程ID列表

**返回**:
- `pd.DataFrame`: 空帧详细信息

**说明**: 获取flag=2的空帧数据

---

#### `parse_frame_slice_db() -> dict`

解析帧切片数据库

**返回**:
- `dict`: 按vsync分组的帧数据

**说明**: 用于卡顿帧分析

---

#### `get_first_frame_timestamp() -> int`

获取第一帧时间戳

**返回**:
- `int`: 第一帧时间戳（纳秒）

**说明**: 用于相对时间计算

---

#### `get_frame_load_statistics() -> dict`

获取帧负载统计信息

**返回**:
- `dict`: 包含平均负载、最大负载、最小负载等统计信息

---

#### `get_top_frame_loads(count: int) -> list`

获取Top帧负载列表

**参数**:
- `count`: 返回的帧数量

**返回**:
- `list`: Top帧负载列表

---

#### `add_frame_load(frame_load: dict) -> None`

添加帧负载到缓存

**参数**:
- `frame_load`: 帧负载字典

**说明**: 将计算好的帧负载添加到内部缓存

---

#### `close_connections() -> None`

关闭数据库连接

**说明**: 关闭trace和perf数据库连接

### 3.7 FrameLoadCalculator

#### `__init__(debug_vsync_enabled: bool = False, cache_manager: FrameCacheManager = None)`

初始化帧负载计算器

**参数**:
- `debug_vsync_enabled`: VSync调试开关，True时正常判断，False时永远不触发VSync条件
- `cache_manager`: 缓存管理器实例

---

#### `calculate_all_frame_loads_fast(trace_df: pd.DataFrame, perf_df: pd.DataFrame) -> list`

快速计算所有帧的负载值

**参数**:
- `trace_df`: 帧数据DataFrame
- `perf_df`: 性能数据DataFrame

**返回**:
- `list`: 帧负载数据列表

**说明**: 快速版本，不进行调用链分析

---

#### `analyze_single_frame(frame: pd.Series, perf_df: pd.DataFrame, perf_conn, step_id: str = None) -> tuple`

分析单个帧的调用链

**参数**:
- `frame`: 帧数据Series
- `perf_df`: 性能数据DataFrame
- `perf_conn`: perf数据库连接
- `step_id`: 步骤ID

**返回**:
- `tuple`: (frame_load, sample_callchains)

**说明**: 计算帧负载并分析调用链

---

#### `analyze_perf_callchain(callchain_id: int, callchain_cache: pd.DataFrame = None, files_cache: pd.DataFrame = None, step_id: str = None) -> list[dict[str, Any]]`

分析perf样本的调用链信息

**参数**:
- `callchain_id`: 调用链ID
- `callchain_cache`: 缓存的callchain数据
- `files_cache`: 缓存的文件数据
- `step_id`: 步骤ID，用于缓存key

**返回**:
- `list[dict[str, Any]]`: 调用链信息列表，每个元素包含symbol和path信息

### 3.8 FramePerfAccessor

#### `__init__(perf_conn)`

初始化FramePerfAccessor

**参数**:
- `perf_conn`: perf数据库连接

---

#### `get_perf_samples() -> pd.DataFrame`

获取性能采样数据

**返回**:
- `pd.DataFrame`: 标准化的性能采样数据

**说明**: 从perf_sample表读取数据，包含时间戳、线程ID、事件计数等信息

---

#### `get_callchain_cache() -> pd.DataFrame`

获取调用链缓存

**返回**:
- `pd.DataFrame`: 调用链数据

**说明**: 从perf_callchain表读取数据

---

#### `get_files_cache() -> pd.DataFrame`

获取文件缓存

**返回**:
- `pd.DataFrame`: 文件数据

**说明**: 从perf_files表读取数据

### 3.9 FrameTraceAccessor

#### `__init__(trace_conn)`

初始化FrameTraceAccessor

**参数**:
- `trace_conn`: trace数据库连接

---

#### `get_frames_data(app_pids: list = None) -> pd.DataFrame`

获取标准化的帧数据，统一管理所有frame_slice数据访问

**参数**:
- `app_pids`: 应用进程ID列表，如果提供则只返回这些进程的数据

**返回**:
- `pd.DataFrame`: 标准化的帧数据

**说明**: 
- 包含帧的所有重要字段
- 关联进程和线程信息
- 支持按进程ID过滤

---

#### `get_empty_frames_with_details(app_pids: list) -> pd.DataFrame`

获取空帧详细信息

**参数**:
- `app_pids`: 应用进程ID列表

**返回**:
- `pd.DataFrame`: 空帧详细信息

**说明**: 获取flag=2的空帧，包含详细信息

---

#### `parse_frame_slice_db() -> dict`

解析帧切片数据库

**返回**:
- `dict`: 按vsync分组的帧数据

**说明**: 
- 按vsync分组组织帧数据
- 用于卡顿帧分析
- 返回格式：{vsync_key: [frame1, frame2, ...]}

---

#### `get_frame_type(frame: dict) -> str`

获取帧类型

**参数**:
- `frame`: 帧数据字典

**返回**:
- `str`: 帧类型（'ui', 'render', 'sceneboard'）

**说明**: 根据进程名称判断帧类型

## 4. 帧标志说明

### 4.1 帧标志定义

- **flag = 0 (FLAG_NORMAL)**: 实际渲染帧不卡帧（正常帧）
- **flag = 1 (FLAG_STUTTER)**: 实际渲染帧卡帧（expectEndTime < actualEndTime为异常）
- **flag = 2 (FLAG_NO_DRAW)**: 数据不需要绘制（空帧，不参与卡顿分析）
- **flag = 3 (FLAG_PROCESS_ERROR)**: rs进程与app进程起止异常（|expRsStartTime - expUiEndTime| < 1ms 正常，否则异常）

### 4.2 帧类型定义

- **type = 0 (FRAME_TYPE_ACTUAL)**: 实际帧
- **type = 1 (FRAME_TYPE_EXPECT)**: 期望帧

### 4.3 进程类型定义

- **PROCESS_TYPE_UI**: UI进程
- **PROCESS_TYPE_RENDER**: 渲染进程
- **PROCESS_TYPE_SCENEBOARD**: SceneBoard进程

## 5. 常量说明

主要常量定义在 `frame_constants.py` 中：

- **时间转换常量**: 毫秒到纳秒、秒到纳秒的转换因子
- **帧分析常量**: 帧时长、FPS窗口大小等
- **卡顿分级阈值**: 1级、2级卡顿的帧数阈值
- **VSync相关常量**: VSync事件计数阈值、符号名称等
- **性能阈值**: 数据库大小、记录数警告/错误阈值
- **分析配置**: Top帧数量、高负载阈值等

## 6. 使用示例

### 6.1 基本使用

```python
from hapray.analyze.unified_frame_analyzer import UnifiedFrameAnalyzer

# 初始化分析器
analyzer = UnifiedFrameAnalyzer(scene_dir='/path/to/scene', top_frames_count=10)

# 执行分析（由BaseAnalyzer框架调用）
result = analyzer._analyze_impl(
    step_dir='step1',
    trace_db_path='/path/to/trace.db',
    perf_db_path='/path/to/perf.db',
    app_pids=[1234, 5678]
)

# 写入报告
analyzer.write_report(result)
```

### 6.2 直接使用核心分析器

```python
from hapray.core.common.frame.frame_core_analyzer import FrameAnalyzerCore

# 初始化核心分析器
core = FrameAnalyzerCore(
    trace_db_path='/path/to/trace.db',
    perf_db_path='/path/to/perf.db',
    app_pids=[1234, 5678],
    step_dir='step1'
)

# 执行各种分析
frame_loads = core.analyze_frame_loads_fast(step_id='step1')
empty_frames = core.analyze_empty_frames()
stuttered_frames = core.analyze_stuttered_frames()
vsync_anomalies = core.analyze_vsync_anomalies()

# 关闭连接
core.close_connections()
```

## 7. 性能优化

### 7.1 缓存机制

- 使用装饰器模式实现自动缓存
- 缓存帧数据、性能数据、调用链等
- 支持缓存命中率统计

### 7.2 快速计算模式

- `analyze_frame_loads_fast()` 只计算负载值，不进行调用链分析
- 大幅提升分析速度

### 7.3 数据库连接管理

- 统一管理数据库连接
- 支持连接复用
- 及时关闭连接释放资源

## 8. 扩展性

### 8.1 添加新的分析器

1. 创建新的分析器类（如 `NewFrameAnalyzer`）
2. 在 `FrameAnalyzerCore` 中初始化新分析器
3. 添加对应的分析方法
4. 在 `UnifiedFrameAnalyzer` 中调用新分析器

### 8.2 自定义分析逻辑

- 各分析器独立，可单独使用
- 支持自定义缓存策略
- 支持自定义负载计算逻辑

## 9. 注意事项

1. **数据库连接**: 使用完毕后必须调用 `close_connections()` 关闭连接
2. **内存管理**: 大数据量时注意内存使用，及时释放DataFrame
3. **时间戳**: 所有时间戳使用纳秒单位，注意单位转换
4. **进程ID**: 确保传入的app_pids正确，否则可能无法获取数据
5. **缓存失效**: 如果数据发生变化，需要清除缓存或重新初始化

