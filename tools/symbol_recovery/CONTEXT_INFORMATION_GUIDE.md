# LLM 上下文信息补充指南

## 当前已包含的上下文信息

### 1. 基础信息
- ✅ **反汇编代码**：函数的 ARM64 反汇编指令
- ✅ **字符串常量**：函数引用的字符串常量
- ✅ **调用的函数**：函数内部调用的其他函数列表
- ✅ **函数偏移量**：函数在 SO 文件中的偏移地址
- ✅ **符号表中的函数名**：如果 SO 文件有符号表，会提供原始函数名
- ✅ **背景信息**：可自定义的上下文描述（如 SO 文件来源、应用信息等）
- ✅ **反编译代码**：如果 radare2 可用，会提供伪 C 代码（比反汇编代码更易读）

### 2. 新增的上下文信息（已实现）

- ✅ **函数边界信息**：
  - 函数起始地址（minbound）
  - 函数结束地址（maxbound）
  - 函数大小（字节数）

- ✅ **指令数量**：函数包含的指令条数

- ✅ **函数复杂度指标**：
  - 基本块数量（nbbs）
  - 控制流边数量（edges）
  - 参数数量（nargs）
  - 局部变量数量（nlocals）

- ✅ **调用统计信息**（与调用堆栈不同）：
  - 调用次数（call_count）：函数被调用的总次数（数值）
  - 指令执行次数（event_count）：函数内指令的总执行次数（数值）
  
  **注意**：这与"调用堆栈信息"不同：
  - **调用堆栈**：描述调用关系（谁调用了这个函数，这个函数调用了谁）
  - **调用统计**：描述调用频率（被调用了多少次，执行了多少次指令）

- ✅ **SO 文件信息**：函数所在的 SO 文件名称

## 可补充但尚未实现的上下文信息

### 1. 调用者信息（Caller Information）
**描述**：哪些函数调用了当前函数

**用途**：
- 了解函数的调用上下文
- 推断函数的使用场景
- 识别函数在调用链中的位置

**实现难度**：中等
- 需要从 `perf.db` 的 `perf_callchain` 表中查询
- 或者使用 radare2 的交叉引用功能（`axt` 命令）

**示例**：
```
调用者函数:
  - libquick.so+0x12345 (调用次数: 100)
  - libquick.so+0x67890 (调用次数: 50)
```

### 2. 函数调用图上下文（Call Graph Context）
**描述**：函数在调用图中的相邻函数

**用途**：
- 了解函数的调用关系
- 推断函数的功能模块
- 识别函数组（相关函数）

**实现难度**：高
- 需要构建完整的调用图
- 需要分析调用关系
- 计算函数之间的相似度

**示例**：
```
相关函数（调用图上下文）:
  - 上游函数: libquick.so+0x11111 (调用当前函数)
  - 下游函数: libquick.so+0x22222 (被当前函数调用)
  - 同级函数: libquick.so+0x33333 (被同一函数调用)
```

### 3. 寄存器使用情况（Register Usage）
**描述**：函数使用的寄存器及其用途

**用途**：
- 推断函数参数（ARM64 使用 x0-x7 传递参数）
- 推断返回值（x0 通常用于返回值）
- 了解函数的寄存器压力

**实现难度**：中等
- 需要分析反汇编代码
- 跟踪寄存器的读写
- 识别参数传递约定

**示例**：
```
寄存器使用:
  - 参数寄存器: x0 (输入参数1), x1 (输入参数2)
  - 返回值寄存器: x0 (返回值)
  - 局部变量: x19-x28 (被保存的寄存器)
```

### 4. 函数参数和返回值信息（Parameters and Return Value）
**描述**：函数接受的参数类型和返回值类型

**用途**：
- 更准确地推断函数签名
- 识别函数类型（如回调函数、工厂函数等）
- 推断函数的功能

**实现难度**：高
- 需要分析函数调用约定
- 需要分析参数的使用方式
- 需要推断类型信息

**示例**：
```
函数签名推断:
  - 参数: void* (x0), int (x1)
  - 返回值: int (x0)
  - 可能签名: int func(void* ptr, int size)
```

### 5. 异常处理信息（Exception Handling）
**描述**：函数是否包含异常处理代码

**用途**：
- 识别错误处理函数
- 推断函数的健壮性
- 识别关键函数（有异常处理）

**实现难度**：中等
- 需要识别异常处理指令（如 `try-catch` 相关代码）
- 需要分析控制流

**示例**：
```
异常处理:
  - 包含异常处理: 是
  - 异常处理类型: C++ exception handling
```

### 6. 函数性能特征（Performance Characteristics）
**描述**：函数的性能相关特征

**用途**：
- 识别热点函数
- 推断函数的计算复杂度
- 识别性能瓶颈

**实现难度**：低（部分信息已有）
- 已有：调用次数、指令执行次数
- 可补充：循环次数、分支预测信息等

**示例**：
```
性能特征:
  - 热点函数: 是（调用次数 > 1000）
  - 平均执行时间: 10ms
  - 循环复杂度: O(n)
```

### 7. 函数依赖关系（Dependencies）
**描述**：函数依赖的库和模块

**用途**：
- 推断函数的功能领域（如网络、文件系统等）
- 识别第三方库函数
- 推断函数的实现方式

**实现难度**：低
- 可以从调用的函数中推断
- 可以从字符串常量中推断

**示例**：
```
依赖关系:
  - 系统调用: open, read, write
  - 库函数: malloc, free
  - 第三方库: libcurl (网络库)
```

### 8. 函数注释和文档（Comments and Documentation）
**描述**：如果 SO 文件包含调试信息，可能有函数注释

**用途**：
- 直接获取函数说明
- 验证推断结果
- 提供更准确的上下文

**实现难度**：低（如果 SO 文件有调试信息）
- 需要解析 DWARF 调试信息
- 需要解析符号表注释

**示例**：
```
函数文档:
  - 注释: "Allocates memory for the given size"
  - 来源: DWARF 调试信息
```

## 实现优先级建议

### 高优先级（建议立即实现）
1. ✅ **函数边界信息** - 已实现
2. ✅ **指令数量** - 已实现
3. ✅ **调用统计信息** - 已实现
4. ✅ **SO 文件信息** - 已实现
5. ✅ **函数复杂度指标** - 已实现

### 中优先级（建议后续实现）
1. **调用者信息** - 有助于理解函数上下文
2. **寄存器使用情况** - 有助于推断函数签名
3. **函数依赖关系** - 有助于推断函数功能领域

### 低优先级（可选实现）
1. **函数调用图上下文** - 实现复杂，收益有限
2. **函数参数和返回值信息** - 需要复杂的类型推断
3. **异常处理信息** - 对大多数函数不适用
4. **函数性能特征** - 已有部分信息，补充价值有限
5. **函数注释和文档** - 大多数 SO 文件没有调试信息

## 使用建议

### 1. 根据分析目标选择上下文信息
- **符号恢复**：重点使用函数边界、指令数量、调用统计
- **功能分析**：重点使用字符串常量、调用的函数、依赖关系
- **性能分析**：重点使用调用统计、性能特征

### 2. 避免信息过载
- 不要添加过多上下文信息，可能导致 prompt 过长
- 优先使用对分析最有帮助的信息
- 对于批量分析，减少每个函数的上下文信息量

### 3. 动态调整
- 根据函数类型动态选择上下文信息
- 对于简单函数，减少上下文信息
- 对于复杂函数，增加上下文信息

## 总结

当前实现已经包含了**最关键的上下文信息**：
- 函数边界和大小
- 指令数量
- 调用统计
- 函数复杂度指标
- SO 文件信息

这些信息足以支持大多数符号恢复和功能分析任务。其他上下文信息可以根据具体需求逐步补充。

